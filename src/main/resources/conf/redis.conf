# Redis configuration file example

# Note on units: when memory size is needed, it is possible to specify
# it in the usual form of 1k 5GB 4M and so forth:
# 关于单位的注意事项：当需要内存大小时，可以指定
# 以1k 5GB 4M的通常形式等等
#
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
#
# units are case insensitive so 1GB 1Gb 1gB are all the same.

################################## INCLUDES ###################################

# Include one or more other config files here.
# This is useful if you have a standard template that goes to all Redis servers but also need to customize a few per-server settings.
# Include files can include other files, so use this wisely.
# 在此处包括一个或多个其他配置文件。
# 如果您具有可用于所有Redis服务器的标准模板，但还需要自定义一些每服务器设置，则此功能很有用。
# 包含文件可以包含其他文件，因此请明智地使用此文件。。
#
# Notice option "include" won't be rewritten by command "CONFIG REWRITE" from admin or Redis Sentinel.
# Since Redis always uses the last processed line as value of a configuration directive,
# you'd better put includes at the beginning of this file to avoid overwriting config change at runtime.
# 注意，选项“ include”将不会被admin或Redis Sentinel中的命令“ CONFIG REWRITE”重写。
# 由于Redis始终使用最后处理的行作为配置指令的值，
# 因此最好在此文件的开头放置include，以避免在运行时覆盖配置更改。
#
# If instead you are interested in using includes to override configurationoptions,
# it is better to use include as the last line.
# 相反，如果您有兴趣使用include覆盖配置选项，最好将include作为最后一行。
#
# include .\path\to\local.conf
# include c:\path\to\other.conf

################################## NETWORK #####################################

# By default, if no "bind" configuration directive is specified,
# Redis listensfor connections from all the network interfaces available on the server.
# It is possible to listen to just one or multiple selected interfaces using the "bind" configuration directive,
# followed by one or more IP addresses.
# 默认情况下，如果未指定“ bind”配置指令，
# Redis侦听来自服务器上所有可用网络接口的连接。
# 可以使用“ bind”配置指令仅侦听一个或多个选定的接口，后跟一个或多个IP地址。
#
# Examples:
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1 ::1
#
# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the internet,
# binding to all the interfaces is dangerous and will expose the instance to everybody on the internet.
# So by default we uncomment the following bind directive,
# that will force Redis to listen only into the IPv4 lookback interface address
# (this means Redis will be able to accept connections only from clients running into the same computer it is running).
# ~~~警告~~~如果运行Redis的计算机直接暴露于Internet
# 绑定到所有接口都是危险的，并且会将实例暴露给Internet上的所有人。
# 因此，默认情况下，我们取消注释以下绑定指令，
# 将强制Redis仅侦听IPv4回溯接口地址
#（这意味着Redis将只能接受来自运行在同一台计算机上的客户端的连接）。
#
# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
# JUST COMMENT THE FOLLOWING LINE.
# 如果您确定要立即侦听所有界面只需注意以下几行。
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
bind 127.0.0.1

# Protected mode is a layer of security protection,
# in order to avoid that Redis instances left open on the internet are accessed and exploited.
# 保护模式是安全保护层，为避免访问和利用Internet上打开的Redis实例。
#
# When protected mode is on and if:
#
# 1) The server is not binding explicitly to a set of addresses using the
#    "bind" directive.
# 2) No password is configured.
# 启用保护模式时，如果：
# 1）服务器未使用以下命令明确绑定到一组地址“ bind”指令。
# 2）未配置密码。
#
# The server only accepts connections from clients connecting from the IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1,
# and from Unix domain sockets.
# 服务器仅接受来自客户端的连接，这些客户端从IPv4和IPv6回送地址127.0.0.1和:: 1,
# 以及从Unix域套接字进行连接。
#
# By default protected mode is enabled.
# You should disable it only if you are sure you want clients from other hosts to connect to Redis even if no authentication is configured,
# nor a specific set of interfaces are explicitly listed using the "bind" directive.
# 默认情况下启用保护模式。
# 仅当您确定即使未配置身份验证时也希望其他主机的客户端连接到Redis，才应禁用它。
# 也不使用“ bind”指令显式列出一组特定的接口。
protected-mode yes

# Accept connections on the specified port, default is 6379 (IANA #815344).
# If port 0 is specified Redis will not listen on a TCP socket.
port 6379

# TCP listen() backlog.
#
# In high requests-per-second environments you need an high backlog in order to avoid slow clients connections issues.
# Note that the Linux kernel will silently truncate it to the value of /proc/sys/net/core/somaxconn so make sure to raise both the value of somaxconn and tcp_max_syn_backlog in order to get the desired effect.
# 在每秒请求数很高的环境中，您需要大量积压，以避免客户端连接速度慢的问题。
# 请注意，Linux内核将以无提示的方式将其截断为/ proc / sys / net / core / somaxconn的值，
# 因此请确保同时提高somaxconn和tcp_max_syn_backlog的值，以获得所需的效果。
tcp-backlog 511

# Unix socket.
#
# Specify the path for the Unix socket that will be used to listen for incoming connections.
# There is no default, so Redis will not listen on a unix socket when not specified.
# 指定用于监听传入连接的Unix套接字的路径。
# 没有默认值，因此在未指定的情况下，Redis不会在Unix套接字上侦听
#
# unixsocket /tmp/redis.sock
# unixsocketperm 700

# Close the connection after a client is idle for N seconds (0 to disable)
# 客户端闲置N秒后关闭连接（0禁用）
timeout 0

# TCP keepalive.
#
# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence of communication.
# This is useful for two reasons:
# 如果不为零，请在没有通信的情况下使用SO_KEEPALIVE向客户端发送TCP ACK。
# 这很有用，有两个原因：
#
# 1) Detect dead peers.
# 2) Take the connection alive from the point of view of network
#    equipment in the middle.
# 1）检测死亡的同伴。
# 2）从网络角度来看，保持连接活跃设备在中间。
#
# On Linux, the specified value (in seconds) is the period used to send ACKs.
# Note that to close the connection the double of the time is needed.
# On other kernels the period depends on the kernel configuration.
# 在Linux上，指定的值（以秒为单位）是用于发送ACK的时间段。
# 请注意，关闭连接需要两倍的时间。在其他内核上，期限取决于内核配置。
#
# A reasonable value for this option is 60 seconds.
# 此选项的合理值为60秒。
tcp-keepalive 0

################################# GENERAL #####################################

# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
# 默认情况下，Redis不会作为守护程序运行。如果需要，请使用“是”。
# 注意，Redis守护进程将在/var/run/redis.pid中写入一个pid文件
# NOT SUPPORTED ON WINDOWS daemonize no

# If you run Redis from upstart or systemd, Redis can interact with your
# 如果您从新贵或systemd运行Redis，Redis可以与您的
# supervision tree. Options:
#   supervised no      - no supervision interaction(没有监督互动)
#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode(通过将Redis置于SIGSTOP模式来发出信号)
#   supervised systemd - signal systemd by writing(通过写系统信号) READY=1 to $NOTIFY_SOCKET
#   supervised auto    - detect upstart or systemd method based on
#                        UPSTART_JOB or NOTIFY_SOCKET environment variables(基于检测新贵或系统方法UPSTART_JOB或NOTIFY_SOCKET环境变量)
# Note: these supervision methods only signal "process is ready."
#       They do not enable continuous liveness pings back to your supervisor.
# 这些监督方法仅表示“过程已准备就绪”。他们无法使您的主管连续不断地进行ping操作
# NOT SUPPORTED ON WINDOWS supervised no

# If a pid file is specified, Redis writes it where specified at startup and removes it at exit.
# 如果指定了pid文件，则Redis会在启动时将其写入指定位置，然后在退出时将其删除。
#
# When the server runs non daemonized, no pid file is created if none is specified in the configuration.
# When the server is daemonized, the pid file is used even if not specified, defaulting to "/var/run/redis.pid".
# 当服务器在非守护进程中运行时，如果在配置中未指定任何pid文件，则不会创建该文件。
# 守护服务器时，即使未指定，也会使用pid文件，默认为“ /var/run/redis.pid”
#
# Creating a pid file is best effort:
# if Redis is not able to create it nothing bad happens, the server will start and run normally.
# 创建pid文件是最大的努力：
# 如果Redis无法创建它，则不会发生任何不良情况，服务器将正常启动并运行。
# NOT SUPPORTED ON WINDOWS pidfile /var/run/redis.pid
# 不支持WINDOWS pidfile /var/run/redis.pid
# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
# 指定服务器详细级别。这可以是以下之一：
#   调试（很多信息，对于开发/测试很有用）
#   详细（很多很少有用的信息，但不会像调试级别那样混乱）
#   通知（适度冗长，可能在生产中需要什么）
#   警告（仅记录非常重要/重要的消息）
loglevel notice

# Specify the log file name. Also 'stdout' can be used to force Redis to log on the standard output.
# 指定日志文件名。还可以使用“ stdout”强制Redis登录标准输出。
logfile ""

# To enable logging to the Windows EventLog, just set 'syslog-enabled' to yes,
# and optionally update the other syslog parameters to suit your needs.
# If Redis is installed and launched as a Windows Service, this will automatically be enabled.
# 要启用到Windows EventLog的日志记录，只需将'syslog-enabled'设置为yes，
# 并根据需要更新其他syslog参数。如果Redis是作为Windows服务安装并启动的，它将自动启用。
# syslog-enabled no


# Specify the source name of the events in the Windows Application log.
# syslog-ident redis
# 在Windows应用程序日志中指定事件的源名称。syslog-ident redis

# Set the number of databases. The default database is DB 0, you can select a different one on a per-connection basis using SELECT <dbid> where dbid is a number between 0 and 'databases'-1
# 设置数据库数。默认数据库为DB 0，
# 您可以使用SELECT <dbid>在每个连接的基础上选择一个不同的数据库，其中dbid是介于0和'databases'-1之间的数字
databases 16

################################ SNAPSHOTTING  ################################
#
# Save the DB on disk:
#
#   save <seconds> <changes>
#
#   Will save the DB if both the given number of seconds and the given number of write operations against the DB occurred.
#   如果同时发生了给定的秒数和给定的针对数据库的写操作数，则将保存数据库。
#
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
#   在下面的示例中，行为将是保存：
#   在900秒（15分钟）后，如果至少更改了1个键
#   300秒（5分钟）后，如果至少更改了10个按键
#   60秒后，如果至少更改了10000个键
#
#   Note: you can disable saving completely by commenting out all "save" lines.
#   注意：您可以通过注释掉所有“保存”行来完全禁用保存。
#
#   It is also possible to remove all the previously configured save points by adding a save directive with a single empty string argument like in the following example:
#   也可以通过添加带有单个空字符串参数的save指令来删除所有先前配置的保存点，如以下示例所示：
#   save ""

save 900 1
save 300 10
save 60 10000

# By default Redis will stop accepting writes if RDB snapshots are enabled (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting on disk properly,
# otherwise chances are that no one will notice and some disaster will happen.
# 默认情况下，如果启用RDB快照（至少一个保存点）并且最新的后台保存失败，则Redis将停止接受写入。
# 这将使用户（以一种困难的方式）意识到数据无法正确地持久存储在磁盘上，
# 否则没有人会注意到，并且将发生一些灾难。
#
# If the background saving process will start working again Redis will automatically allow writes again.
# 如果后台保存过程将再次开始工作，则Redis将自动允许再次写入。
#
# However if you have setup your proper monitoring of the Redis server and persistence,
# you may want to disable this feature so that Redis will continue to work as usual even if there are problems with disk, permissions, and so forth.
# 但是，如果您已经设置了对Redis服务器和持久性的适当监视，
# 您可能希望禁用此功能，以便即使磁盘，权限等出现问题，Redis也将继续照常工作。
stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases?
# For default that's set to 'yes' as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but the dataset will likely be bigger if you have compressible values or keys.
# 转储.rdb数据库时使用LZF压缩字符串对象？
# 默认情况下将其设置为“是”，因为它几乎总是胜利。
# 如果要在保存子项中保存一些CPU，请将其设置为“ no”，
# 但是如果您具有可压缩的值或键，则数据集可能会更大。
rdbcompression yes

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance hit to pay (around 10%) when saving and loading RDB files,
# so you can disable it for maximum performances.
# 从RDB版本5开始，CRC64校验和位于文件末尾。
# 这样可以提高格式的抗破坏能力，但是在保存和加载RDB文件时会降低性能（约10％），
# 因此您可以将其禁用以实现最佳性能。
#
# RDB files created with checksum disabled have a checksum of zero that will tell the loading code to skip the check.
# 在禁用校验和的情况下创建的RDB文件的校验和为零，这将指示加载代码跳过该校验。
rdbchecksum yes

# The filename where to dump the DB
# 转储数据库的文件名
dbfilename dump.rdb

# The working directory.
#
# The DB will be written inside this directory, with the filename specified above using the 'dbfilename' configuration directive.
# 数据库将被写入该目录内，文件名使用“ dbfilename”配置指令在上面指定。
#
# The Append Only File will also be created inside this directory.
# 也将在此目录中创建仅附加文件。
#
# Note that you must specify a directory here, not a file name.
# 请注意，您必须在此处指定目录，而不是文件名。
dir ./

################################# REPLICATION #################################

# Master-Slave replication. Use slaveof to make a Redis instance a copy of another Redis server. A few things to understand ASAP about Redis replication.
#
# 1) Redis replication is asynchronous, but you can configure a master to stop accepting writes if it appears to be not connected with at least a given number of slaves.
# 2) Redis slaves are able to perform a partial resynchronization with the master if the replication link is lost for a relatively small amount of time. You may want to configure the replication backlog size (see the next sections of this file) with a sensible value depending on your needs.
# 3) Replication is automatic and does not need user intervention. After a network partition slaves automatically try to reconnect to masters and resynchronize with them.
# 主从复制。使用slaveof使Redis实例成为另一个Redis服务器的副本。尽快了解有关Redis复制的几件事。
# 1）Redis复制是异步的，但是您可以将主服务器配置为如果似乎未与至少给定数量的从服务器连接，则停止接受写入。
# 2）如果复制链接在相对较短的时间内丢失，则Redis从属服务器能够与主服务器执行部分重新同步。
     您可能需要根据需要将复制积压大小（请参阅此文件的下一部分）配置为合理的值。
# 3）复制是自动的，不需要用户干预。网络分区后，从站将自动尝试重新连接到主站，并与它们重新同步。
# slaveof <masterip> <masterport>

# If the master is password protected (using the "requirepass" configuration directive below) it is possible to tell the slave to authenticate before starting the replication synchronization process,
# otherwise the master will refuse the slave request.
# 如果主服务器受密码保护（使用下面的“ requirepass”配置指令），
# 则可以在开始复制同步过程之前告诉从服务器进行身份验证，
# 否则主服务器将拒绝从服务器请求。
#
# masterauth <master-password>

# When a slave loses its connection with the master, or when the replication is still in progress,
# the slave can act in two different ways:
#
# 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will still reply to client requests, possibly with out of date data, or the data set may just be empty if this is the first synchronization.
#
# 2) if slave-serve-stale-data is set to 'no' the slave will reply with an error "SYNC with master in progress" to all the kind of commands but to INFO and SLAVEOF.
# 当从属服务器失去与主控服务器的连接时，或者仍在进行复制时，从服务器可以通过两种不同的方式行动：
# 1）如果slave-serve-stale-data设置为“ yes”（默认值），则slave仍将回复客户端请求，可能包含过期数据，
#    或者如果这是第一个，则数据集可能为空同步。
# 2）如果slave-serve-stale-data设置为“ no”，则从服务器将对除INFO和SLAVEOF以外的所有命令返回“与主机进行同步”错误。
#
slave-serve-stale-data yes

# You can configure a slave instance to accept writes or not.
# Writing against a slave instance may be useful to store some ephemeral data
# (because data written on a slave will be easily deleted after resync with the master)
# but may also cause problems if clients are writing to it because of a misconfiguration.
# 您可以配置一个从属实例以接受或不接受写入。
# 对从属实例进行写操作可能对存储一些临时数据很有用
#（因为与主实例重新同步后，很容易删除写在从属上的数据）
# 但如果客户端由于配置错误而向其写入数据，也会导致问题。
#
# Since Redis 2.6 by default slaves are read-only.
#
# Note: read only slaves are not designed to be exposed to untrusted clients on the internet.
# It's just a protection layer against misuse of the instance.
# Still a read only slave exports by default all the administrative commands such as CONFIG, DEBUG, and so forth.
# To a limited extent you can improve security of read only slaves using 'rename-command' to shadow all the administrative / dangerous commands.
# 注意：只读从站并非旨在向Internet上不受信任的客户端公开。
# 这只是防止实例滥用的保护层。
# 默认仍然是只读从属设备，导出所有管理命令，例如CONFIG，DEBUG等。
# 在一定程度上，您可以使用'rename-command'隐藏所有管理/危险命令来提高只读从站的安全性。
slave-read-only yes

# Replication SYNC strategy: disk or socket.
# 复制SYNC策略：磁盘或套接字
#
# -------------------------------------------------------
# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY
# -------------------------------------------------------
#
# New slaves and reconnecting slaves that are not able to continue the replication process just receiving differences,
# need to do what is called a "full synchronization".
# An RDB file is transmitted from the master to the slaves.
# The transmission can happen in two different ways:
#
# 1) Disk-backed: The Redis master creates a new process that writes the RDB file on disk. Later the file is transferred by the parent process to the slaves incrementally.
# 2) Diskless: The Redis master creates a new process that directly writes the RDB file to slave sockets, without touching the disk at all.
# 新的从属服务器和重新连接的从属服务器，仅在接收到差异后无法继续复制过程，
# 需要执行所谓的“完全同步”。RDB文件从主机发送到从机。
# 传输可以两种不同的方式发生：
# 1）支持磁盘：Redis主服务器创建一个新过程，将RDB文件写入磁盘。稍后，文件由父进程逐步传输到从属服务器。
# 2）无盘：Redis主服务器创建一个新进程，该进程将RDB文件直接写入从属套接字，而完全不接触磁盘。
#
# With disk-backed replication, while the RDB file is generated,
# more slaves can be queued and served with the RDB file as soon as the current child producing the RDB file finishes its work.
# With diskless replication instead once the transfer starts, new slaves arriving will be queued and a new transfer will start when the current one terminates.
# 通过磁盘支持的复制，在生成RDB文件的同时，一旦产生RDB文件的当前子节点完成工作，就可以将更多的从属队列并与RDB文件一起使用。
# 使用无盘复制代替，一旦传输开始，新的从属设备将排队，并且当当前的从属设备终止时将开始新的传输。
#
# When diskless replication is used,
# the master waits a configurable amount of time (in seconds) before starting the transfer in the hope that multiple slaves will arrive and the transfer can be parallelized.
# 当使用无盘复制时，
# 主服务器在开始传输之前等待一段可配置的时间（以秒为单位），
# 以希望多个从服务器到达并且传输可以并行化。。
#
# With slow disks and fast (large bandwidth) networks, diskless replication works better.
# 对于慢速磁盘和快速（大带宽）网络，无盘复制效果更好。
repl-diskless-sync no

# When diskless replication is enabled,
# it is possible to configure the delay the server waits in order to spawn the child that transfers the RDB via socket to the slaves.
# 启用无盘复制后，
# 可以配置服务器等待的延迟，以便生成通过套接字将RDB传输到从属服务器的子代。
# This is important since once the transfer starts,
# it is not possible to serve new slaves arriving, that will be queued for the next RDB transfer,
# so the server waits a delay in order to let more slaves arrive.
# 这很重要，因为一旦传输开始，
# 无法为到达的新从服务器提供服务，新的从服务器将被排队等待下一次RDB传输，
# 因此服务器等待延迟以便让更多从服务器到达。
#
# The delay is specified in seconds, and by default is 5 seconds.
# To disable it entirely just set it to 0 seconds and the transfer will start ASAP.
# 延迟以秒为单位指定，默认情况下为5秒。
# 要完全禁用它，只需将其设置为0秒，传输将尽快开始
repl-diskless-sync-delay 5

# Slaves send PINGs to server in a predefined interval.
# It's possible to change this interval with the repl_ping_slave_period option. The default value is 10 seconds.
# 从站以预定的时间间隔将PING发送到服务器。
# 可以使用repl_ping_slave_period选项更改此间隔。默认值为10秒。
# repl-ping-slave-period 10

# The following option sets the replication timeout for:
#
# 1) Bulk transfer I/O during SYNC, from the point of view of slave.
# 2) Master timeout from the point of view of slaves (data, pings).
# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).
# 以下选项为以下项设置复制超时：
# 1）从站的角度来看，在SYNC期间进行批量传输I / O。
# 2）从从站（数据，Ping）的角度来看，主站超时。
# 3）从主机角度来看从机超时（REPLCONF ACK pings）。
#
# It is important to make sure that this value is greater than the value specified for repl-ping-slave-period otherwise a timeout will be detected every time there is low traffic between the master and the slave.
# 重要的是要确保该值大于为repl-ping-slave-period指定的值，否则，每当主机和从机之间的通信量较低时，就会检测到超时。
# repl-timeout 60

# Disable TCP_NODELAY on the slave socket after SYNC?
# SYNC之后，在从属套接字上禁用TCP_NODELAY？
#
# If you select "yes" Redis will use a smaller number of TCP packets and less bandwidth to send data to slaves.
# But this can add a delay for the data to appear on the slave side, up to 40 milliseconds with Linux kernels using a default configuration.
# 如果选择“是”，则Redis将使用更少的TCP数据包和更少的带宽将数据发送到从站。
# 但这会增加数据显示在从属端的延迟，对于使用默认配置的Linux内核，此延迟最多40毫秒。
#
# If you select "no" the delay for data to appear on the slave side will be reduced but more bandwidth will be used for replication.
# 如果选择“否”，将减少数据出现在从属端的延迟，但是将使用更多带宽进行复制。
#
# By default we optimize for low latency, but in very high traffic conditions or when the master and slaves are many hops away, turning this to "yes" may be a good idea.
# 默认情况下，我们针对低延迟进行优化，但是在流量非常高的情况下，
# 或者当主服务器和从服务器距离很多跳时，将其设置为“是”可能是个好主意。
repl-disable-tcp-nodelay no

# Set the replication backlog size. The backlog is a buffer that accumulates slave data when slaves are disconnected for some time,
# so that when a slave wants to reconnect again, often a full resync is not needed,
# but a partial resync is enough, just passing the portion of data the slave missed while disconnected.
# 设置复制积压大小。待办事项是一个缓冲区，当从属设备断开连接一段时间后，该缓冲区会累积从属数据，
# 因此，当从属设备想要重新连接时，通常不需要完全重新同步，
# 但是部分重新同步就足够了，只需传递"从机"在断开连接时错过了的那部分数据即可。
#
# The bigger the replication backlog, the longer the time the slave can be disconnected and later be able to perform a partial resynchronization.
# 复制待办事项越大，从属服务器可以断开连接并稍后能够执行部分重新同步的时间越长。
#
# The backlog is only allocated once there is at least a slave connected.
# 仅当至少有一个从站连接时，才分配积压。
#
# repl-backlog-size 1mb

# After a master has no longer connected slaves for some time, the backlog will be freed.
# The following option configures the amount of seconds that need to elapse,
# starting from the time the last slave disconnected, for the backlog buffer to be freed.
# 当主站不再连接从站一段时间后，积压的事务将被释放。
# 以下选项配置了从释放最后一个从属服务器开始到释放待办事项缓冲区所需的秒数。
#
# A value of 0 means to never release the backlog.
# 值为0表示从不释放积压
#
# repl-backlog-ttl 3600

# The slave priority is an integer number published by Redis in the INFO output.
# It is used by Redis Sentinel in order to select a slave to promote into a master if the master is no longer working correctly.
# 从机优先级是Redis在INFO输出中发布的整数。
# Redis Sentinel使用它来选择一个从属服务器，如果主服务器无法正常工作，则将该主服务器提升为主服务器。
#
# A slave with a low priority number is considered better for promotion,
# so for instance if there are three slaves with priority 10, 100, 25 Sentinel will pick the one with priority 10, that is the lowest.
# 优先级低的从机被认为更适合提升，
# 例如，如果有三个优先级为10、100、25的从机，Sentinel将选择优先级为10的从机，这是最低的。
#
# However a special priority of 0 marks the slave as not able to perform the role of master,
# so a slave with priority of 0 will never be selected by Redis Sentinel for promotion.
# 但是，特殊优先级0会将从属标记为不能执行主角色，
# 因此Redis Sentinel永远不会选择优先级为0的从属进行升级
#
# By default the priority is 100.
slave-priority 100

# It is possible for a master to stop accepting writes if there are less than N slaves connected, having a lag less or equal than M seconds.
# 如果连接的从站少于N个，且延迟小于或等于M秒，则主机可能会停止接受写操作。
#
# The N slaves need to be in "online" state.
# N个从站需要处于“在线”状态
#
# The lag in seconds, that must be <= the specified value, is calculated from the last ping received from the slave, that is usually sent every second.
# 延迟（以秒为单位）必须小于等于指定值，该延迟是从从设备收到的最后一次ping计算得出的，通常每秒钟发送一次。
# This option does not GUARANTEE that N replicas will accept the write,
# but will limit the window of exposure for lost writes in case not enough slaves are available,
# to the specified number of seconds.
# 此选项不能保证N个副本将接受写入，但是如果没有足够的从服务器可用，
# 则会限制丢失写操作的暴露窗口，为指定的秒数。
#
# For example to require at least 3 slaves with a lag <= 10 seconds use:
# 例如，要求至少3个从属时间小于等于10秒的从属，请使用：
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# Setting one or the other to 0 disables the feature.
# 将一个或另一个设置为0将禁用该功能。
#
# By default min-slaves-to-write is set to 0 (feature disabled) and min-slaves-max-lag is set to 10.
# 默认情况下，min-slaves-to-write设置为0（禁用功能），min-slaves-max-lag设置为10。

################################## SECURITY ###################################

# Require clients to issue AUTH <PASSWORD> before processing any other commands.
# This might be useful in environments in which you do not trust others with access to the host running redis-server.
# 要求客户端在处理任何其他命令之前发出AUTH <PASSWORD>。
# 在您不信任其他人无法访问运行redis-server的主机的环境中，这可能很有用。
#
# This should stay commented out for backward compatibility and because most people do not need auth (e.g. they run their own servers).
# 为了向后兼容，应该保留此注释，因为大多数人不需要身份验证（例如，他们运行自己的服务器）。
#
# Warning: since Redis is pretty fast an outside user can try up to 150k passwords per second against a good box.
# This means that you should use a very strong password otherwise it will be very easy to break.
# 警告：由于Redis的速度非常快，外部用户可以在一个不错的机器上尝试每秒最多150k密码。
# 这意味着您应该使用非常安全的密码，否则将很容易破解。
#
# requirepass foobared

# Command renaming.
# 命令重命名
#
# It is possible to change the name of dangerous commands in a shared environment.
# For instance the CONFIG command may be renamed into something hard to guess so that it will still be available for internal-use tools but not available for general clients.
# 可以在共享环境中更改危险命令的名称。
# 例如，CONFIG命令可能被重命名为难以猜测的名称，因此它仍可用于内部使用的工具，但不适用于一般客户。
#
# Example:
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# It is also possible to completely kill a command by renaming it into an empty string:
# 通过将命令重命名为空字符串也可以完全取消命令：
#
# rename-command CONFIG ""
#
# Please note that changing the name of commands that are logged into the AOF file or transmitted to slaves may cause problems.
# 请注意，更改登录到AOF文件或传输给从站的命令的名称可能会导致问题。

################################### LIMITS ####################################

# Set the max number of connected clients at the same time.
# By default this limit is set to 10000 clients,
# however if the Redis server is not able to configure the process file limit to allow for the specified limit the max number of allowed clients is set to the current file limit minus 32 (as Redis reserves a few file descriptors for internal uses).
# 同时设置最大连接客户端数。
# 默认情况下，此限制设置为10000个客户端，
# 但是，如果Redis服务器无法将进程文件限制配置为允许指定的限制，
# 则允许的最大客户端数设置为当前文件限制减去32（以Redis为准）保留一些文件描述符供内部使用）。
#
# Once the limit is reached Redis will close all the new connections sending an error 'max number of clients reached'.
# 旦达到限制，Redis将关闭所有新连接，并发送错误消息“已达到最大客户端数”。
#
# maxclients 10000

# If Redis is to be used as an in-memory-only cache without any kind of persistence,
# then the fork() mechanism used by the background AOF/RDB persistence is unnecessary.
# As an optimization, all persistence can be turned off in the Windows version of Redis.
# This will redirect heap allocations to the system heap allocator,
# and disable commands that would otherwise cause fork() operations: BGSAVE and BGREWRITEAOF.
# This flag may not be combined with any of the other flags that configure AOF and RDB operations.
# persistence-available [(yes)|no]

# 如果将Redis用作没有任何持久性的纯内存缓存，
# 则不需要后台AOF / RDB持久性使用的fork（）机制。
# 作为一种优化，可以在Windows版本的Redis中关闭所有持久性。
# 这会将堆分配重定向到系统堆分配器，并禁用导致fork（）操作的命令：BGSAVE和BGREWRITEAOF。
# 此标志不得与配置AOF和RDB操作的任何其他标志组合。
# 持久性可用[（是）|否]

# Don't use more memory than the specified amount of bytes.
# When the memory limit is reached Redis will try to remove keys according to the eviction policy selected (see maxmemory-policy).
# 使用的内存不要超过指定的字节数。
# 当达到内存限制时，Redis将尝试根据所选的逐出策略来删除密钥（请参阅maxmemory-policy）
#
# If Redis can't remove keys according to the policy, or if the policy is set to 'noeviction',
# Redis will start to reply with errors to commands that would use more memory,
# like SET, LPUSH, and so on, and will continue to reply to read-only commands like GET.
# 如果Redis无法根据该策略删除密钥，或者如果该策略设置为'noeviction'，
# 则Redis将开始以错误的方式答复将使用更多内存的命令，例如SET，LPUSH等。
# 将继续回复诸如GET之类的只读命令。
#
# This option is usually useful when using Redis as an LRU cache,
# or to set a hard memory limit for an instance (using the 'noeviction' policy).
# 当使用Redis作为LRU缓存时，此选项通常很有用，
# 或设置实例的硬盘限制（使用“ noeviction”策略）。
#
# WARNING: If you have slaves attached to an instance with maxmemory on,
# the size of the output buffers needed to feed the slaves are subtracted from the used memory count,
# so that network problems / resyncs will not trigger a loop where keys are evicted,
# and in turn the output buffer of slaves is full with DELs of keys evicted triggering the deletion of more keys,
# and so forth until the database is completely emptied.
# 警告：如果您将从属服务器连接到启用了maxmemory的实例，
# 从使用的内存计数中减去为从属设备提供所需的输出缓冲区的大小，
# 以便网络问题/重新同步不会触发驱逐密钥的循环，
# 反过来，从属设备的输出缓冲区已装满DEL逐出的密钥触发删除更多密钥，
# 等直到数据库完全清空。
#
# In short... if you have slaves attached it is suggested that you set a lower limit for maxmemory so that there is some free RAM on the system for slave output buffers (but this is not needed if the policy is 'noeviction').
# 简而言之...如果您连接了从属设备，建议您为maxmemory设置一个下限，
# 以便系统上有一些可用的RAM用于从属设备输出缓冲区（但是如果策略为'noeviction'，则不需要这样做）。
#
# WARNING: not setting maxmemory will cause Redis to terminate with an out-of-memory exception if the heap limit is reached.
# 警告：未设置maxmemory会导致Redis在达到堆限制时以内存不足异常终止。
#
# NOTE: since Redis uses the system paging file to allocate the heap memory,
# the Working Set memory usage showed by the Windows Task Manager or by other tools such as ProcessExplorer will not always be accurate.
# For example, right after a background save of the RDB or the AOF files,
# the working set value may drop significantly.
# In order to check the correct amount of memory used by the redis-server to store the data, use the INFO client command.
# The INFO command shows only the memory used to store the redis data,
# not the extra memory used by the Windows process for its own requirements.
# Th3 extra amount of memory not reported by the INFO command can be calculated subtracting the Peak Working Set reported by the Windows Task Manager and the used_memory_peak reported by the INFO command.
# 注意：由于Redis使用系统页面文件来分配堆内存，
# Windows任务管理器或其他工具（例如ProcessExplorer）显示的工作集内存使用情况并不总是准确的。
# 例如，在RDB或AOF文件后台保存后，工作集值可能会大大下降。
# 为了检查redis服务器用于存储数据的正确内存量，请使用INFO client命令。
# INFO命令仅显示用于存储Redis数据的内存，不是Windows进程用于其自身需求的额外内存。
# 可以计算出INFO命令未报告的额外内存量，减去Windows任务管理器报告的“峰值工作集”和INFO命令报告的used_memory_peak。
#
# maxmemory <bytes>

# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory is reached. You can select among five behaviors:
# MAXMEMORY POLICY：达到maxmemory时，Redis将如何选择要删除的内容。您可以选择以下五种行为：
#
# volatile-lru -> remove the key with an expire set using an LRU algorithm
# volatile-lru ->使用LRU算法删除具有过期集的密钥
# allkeys-lru -> remove any key according to the LRU algorithm
# allkeys-lru -> 根据LRU算法删除任何密钥
# volatile-random -> remove a random key with an expire set
# volatile-random -> 删除具有过期集的随机密钥
# allkeys-random -> remove a random key, any key
# allkeys-random -> 删除随机密钥，任何密钥
# volatile-ttl -> remove the key with the nearest expire time (minor TTL)
# volatile-ttl -> 取出最接近到期​​时间（较小的TTL）的密钥
# noeviction -> don't expire at all, just return an error on write operations
# noeviction -> 根本不会过期，只是在写操作时返回错误
#
# Note: with any of the above policies, Redis will return an error on writeoperations, when there are no suitable keys for eviction.
#
#At the date of writing these commands are: set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby getset mset msetnx exec sort
# 注意：使用上述任何策略时，如果没有合适的退出键，Redis将在写操作时返回错误。
# 在编写这些命令时，这些命令是：set setnx setex append incr decr rpush lpush rpushx lpushx linsert lset rpoplpush
# sadd sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby zunionstore zinterstore hset hsetnx
# getset scrby mexec by incrby deexec
#
# The default is:
#
# maxmemory-policy noeviction

# LRU and minimal TTL algorithms are not precise algorithms but approximated algorithms (in order to save memory),
# so you can tune it for speed or accuracy.
# For default Redis will check five keys and pick the one that was used less recently,
# you can change the sample size using the following configuration directive.
# LRU和最小TTL算法不是精确算法，而是近似算法（以节省内存），因此您可以调整它的速度或准确性.
# 对于默认情况，Redis将检查五个键并选择最近使用的键，您可以使用以下配置指令更改样本大小。
#
# The default of 5 produces good enough results. 10 Approximates very closely true LRU but costs a bit more CPU. 3 is very fast but not very accurate.
# 默认值为5会产生足够好的结果。 10非常接近真实的LRU，但要花费更多的CPU。 3非常快，但不是很准确。
#
# maxmemory-samples 5

############################## APPEND ONLY MODE ###############################

# By default Redis asynchronously dumps the dataset on disk.
# This mode is good enough in many applications,
# but an issue with the Redis process or a power outage may result into a few minutes of writes lost (depending on the configured save points).
# 默认情况下，Redis异步将数据集转储到磁盘上。
# 此模式在许多应用程序中都足够好，
# 但是Redis进程问题或断电可能会导致几分钟的写入丢失（取决于配置的保存点）。
#
# The Append Only File is an alternative persistence mode that provides much better durability.
# For instance using the default data fsync policy (see later in the config file) Redis can lose just one second of writes in a dramatic event like a server power outage,
# or a single write if something wrong with the Redis process itself happens, but the operating system is still running correctly.
# 仅附加文件是一种替代的持久性模式，可提供更好的持久性。
# 例如，使用默认数据fsync策略（请参阅配置文件中的稍后内容），
# Redis可能在服务器断电等严重事件中仅损失一秒钟的写操作，
# 或者如果Redis进程本身发生错误，则一次写入，但操作系统仍在正常运行。
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file with the better durability guarantees.
# 可以同时启用AOF和RDB持久性，而不会出现问题。
# 如果启动时启用了AOF，则Redis将加载AOF，即具有更好持久性的文件。
#
# Please check http://redis.io/topics/persistence for more information.

appendonly no

# The name of the append only file (default: "appendonly.aof")
appendfilename "appendonly.aof"

# The fsync() call tells the Operating System to actually write data on disk instead of waiting for more data in the output buffer.
# Some OS will really flush data on disk, some other OS will just try to do it ASAP.
# fsync（）调用告诉操作系统将数据实际写在磁盘上，而不是等待输出缓冲区中的更多数据。
# 某些OS确实会刷新磁盘上的数据，而另一些OS会尝试尽快进行处理。
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants.
# Faster.always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
# 不：不要fsync，只要让OS在需要时刷新数据即可。
# 总是：每次写入仅附加日志后执行fsync。慢，最安全。
# everysec：每秒仅同步一次fsync。妥协。
#
# The default is "everysec", as that's usually the right compromise between speed and data safety.
# It's up to you to understand if you can relax this to "no" that will let the operating system flush the output buffer when it wants,
# for better performances (but if you can live with the idea of some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than everysec.
# 默认值为“ everysec”，因为这通常是速度和数据安全性之间的正确折衷。
# 由您决定是否可以将其放松为“ no”，这将使操作系统在需要时刷新输出缓冲区，
# 以获得更好的性能（但如果您可以忍受某些数据丢失的想法，请考虑使用默认值快照的持久化模式），
# 或相反，请使用“总是”，该速度非常慢，但比秒安全。
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".

# appendfsync always
appendfsync everysec
# appendfsync no

# When the AOF fsync policy is set to always or everysec, and a background saving process (a background save or AOF log background rewriting) is performing a lot of I/O against the disk,
# in some Linux configurations Redis may block too long on the fsync() call.
# Note that there is no fix for this currently, as even performing fsync in a different thread will block our synchronous write(2) call.
# 当AOF fsync策略设置为always或everysec，并且后台保存进程（后台保存或AOF日志后台重写）对磁盘执行大量I / O时，
# 在某些Linux配置中，Redis可能会阻塞太长时间fsync（）调用。
# 注意，目前尚无此修复程序，因为即使在其他线程中执行fsync也将阻止我们的同步write（2）调用。
#
# In order to mitigate this problem it's possible to use the following option that will prevent fsync() from being called in the main process while a BGSAVE or BGREWRITEAOF is in progress.
# 为了减轻此问题，可以使用以下选项来防止在BGSAVE或BGREWRITEAOF进行时在主进程中调用fsync（）
#
# This means that while another child is saving, the durability of Redis is the same as "appendfsync none".
# In practical terms, this means that it is possible to lose up to 30 seconds of log in the worst scenario (with the default Linux settings).
# 这意味着当另一个孩子正在保存时，Redis的持久性与“ appendfsync none”相同。
# 实际上，这意味着在最坏的情况下（使用默认的Linux设置），可能会丢失多达30秒的日志。
#
# If you have latency problems turn this to "yes". Otherwise leave it as "no" that is the safest pick from the point of view of durability.
# 如果您有延迟问题，请将其设置为“是”。
# 否则，从耐久性的角度来看，将其保留为“否”是最安全的选择。
no-appendfsync-on-rewrite no

# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling BGREWRITEAOF when the AOF log size grows by the specified percentage.
# 自动重写仅附加文件。
# 当AOF日志大小增加指定的百分比时，Redis可以自动重写日志文件，隐式调用BGREWRITEAOF。
#
# This is how it works: Redis remembers the size of the AOF file after thelatest rewrite
# (if no rewrite has happened since the restart, the size of the AOF at startup is used).
# 它是这样工作的：Redis会在最近重写之后记住AOF文件的大小（如果自重新启动以来未发生任何重写，则使用启动时AOF的大小）。
#
# This base size is compared to the current size.
# If the current size is bigger than the specified percentage, the rewrite is triggered.
# Also you need to specify a minimal size for the AOF file to be rewritten,
# this is useful to avoid rewriting the AOF file even if the percentage increase is reached but it is still pretty small.
# 将此基本大小与当前大小进行比较。
# 如果当前大小大于指定的百分比，则触发重写。
# 此外，您还需要为要重写的AOF文件指定最小大小，
# 这对避免重写AOF文件很有用，即使达到百分比增加，但它仍然很小。
#
# Specify a percentage of zero in order to disable the automatic AOF rewrite feature.
# 指定零百分比以禁用自动AOF重写功能。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# An AOF file may be found to be truncated at the end during the Redis startup process, when the AOF data gets loaded back into memory.
# This may happen when the system where Redis is running crashes, especially when an ext4 filesystem is mounted without the data=ordered option
# (however this can't happen when Redis itself crashes or aborts but the operating system still works correctly).
# 当AOF数据重新加载回内存时，在Redis启动过程中可能会发现AOF文件在末尾被截断。
# 当运行Redis的系统崩溃时可能会发生这种情况，尤其是在没有data = ordered选项的情况下挂载ext4文件系统时
#（但是，当Redis本身崩溃或中止但操作系统仍然可以正常工作时，不会发生这种情况）。
#
# Redis can either exit with an error when this happens,
# or load as much data as possible (the default now) and start if the AOF file is found to be truncated at the end. The following option controls this behavior.
# 发生这种情况时，Redis可能会退出并显示错误，
# 或加载尽可能多的数据（现在是默认值），如果发现AOF文件最后被截断，则Redis会开始。以下选项控制此行为。
#
# If aof-load-truncated is set to yes, a truncated AOF file is loaded and the Redis server starts emitting a log to inform the user of the event.
# Otherwise if the option is set to no, the server aborts with an error and refuses to start.
# When the option is set to no, the user requires to fix the AOF file using the "redis-check-aof" utility before to restart the server.
# 如果aof-load-truncated设置为yes，则将加载截短的AOF文件，并且Redis服务器将开始发出日志以将事件通知用户。
# 否则，如果该选项设置为no，则服务器将中止并显示错误并拒绝启动。
# 当选项设置为no时，用户需要在重新启动服务器之前使用“ redis-check-aof”实用程序修复AOF文件。
#
# Note that if the AOF file will be found to be corrupted in the middle the server will still exit with an error.
# This option only applies when Redis will try to read more data from the AOF file but not enough bytes will be found.
# 请注意，如果在中间发现AOF文件已损坏，则服务器仍将退出并出现错误。
# 仅当Redis尝试从AOF文件读取更多数据但找不到足够的字节时，此选项才适用。
aof-load-truncated yes

################################ LUA SCRIPTING  ###############################

# Max execution time of a Lua script in milliseconds.
# Lua脚本的最大执行时间（以毫秒为单位）。
#
# If the maximum execution time is reached Redis will log that a script is still in execution after the maximum allowed time and will start to reply to queries with an error.
# 如果达到了最大执行时间，Redis将记录在允许的最大时间后脚本仍在执行中，并将开始以错误答复查询。
#
# When a long running script exceeds the maximum execution time only the SCRIPT KILL and SHUTDOWN NOSAVE commands are available.
# The first can be used to stop a script that did not yet called write commands.
# The second is the only way to shut down the server in the case a write command was already issued by the script but the user doesn't want to wait for the natural termination of the script.
# 如果长时间运行的脚本超过了最大执行时间，则只有“ SCRIPT KILL”和“ SHUTDOWN NOSAVE”命令可用。
# 第一个可用于停止尚未调用写命令的脚本。
# 第二种是在脚本已发出写命令但用户不想等待脚本自然终止的情况下关闭服务器的唯一方法。
#
# Set it to 0 or a negative value for unlimited execution without warnings.
# 将其设置为0或负值可无警告地无限执行。
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################
#
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code,
# however in order to mark it as "mature" we need to wait for a non trivial percentage of users to deploy it in production.
# 警告实验：Redis Cluster被认为是稳定的代码，
# 但是为了将其标记为“成熟”，我们需要等待不小的用户百分比将其部署到生产环境中。
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# Normal Redis instances can't be part of a Redis Cluster; only nodes that are started as cluster nodes can.
# In order to start a Redis instance as a cluster node enable the cluster support uncommenting the following:
# 普通Redis实例不能属于Redis集群；只有作为群集节点启动的节点可以。
# 为了将Redis实例作为群集节点启动，请启用群集支持，取消注释以下内容：
#
# cluster-enabled yes

# Every cluster node has a cluster configuration file.
# This file is not intended to be edited by hand.
# It is created and updated by Redis nodes.
# Every Redis Cluster node requires a different cluster configuration file.
# Make sure that instances running in the same system do not have overlapping cluster configuration file names.
# 每个群集节点都有一个群集配置文件。
# 请勿手工编辑此文件。
# 它由Redis节点创建和更新。
# 每个Redis群集节点都需要一个不同的群集配置文件。
# 确保在同一系统上运行的实例没有重叠的集群配置文件名。
#
# cluster-config-file nodes-6379.conf

# Cluster node timeout is the amount of milliseconds a node must be unreachable for it to be considered in failure state.
# Most other internal time limits are multiple of the node timeout.
# 群集节点超时是一个节点必须不可达的毫秒数，才能将其视为故障状态。
# 其他大多数内部时间限制是节点超时的倍数。
#
# cluster-node-timeout 15000

# A slave of a failing master will avoid to start a failover if its data looks too old.
#
# There is no simple way for a slave to actually have a exact measure of its "data age",
# so the following two checks are performed:
#
# 1) If there are multiple slaves able to failover,
#    they exchange messages in order to try to give an advantage to the slave with the best replication offset (more data from the master processed).
#    Slaves will try to get their rank by offset, and apply to the start of the failover a delay proportional to their rank.
#
# 2) Every single slave computes the time of the last interaction withits master.
#    This can be the last ping or command received (if the masteris still in the "connected" state),
#    or the time that elapsed since the disconnection with the master (if the replication link is currently down).
#    If the last interaction is too old, the slave will not try to failover at all.
# 如果发生故障的主机的从属设备的数据看起来太旧，它将避免启动故障转移。
#
# 没有简单的方法可以使从站实际测量其“数据年龄”，＃因此执行以下两项检查：
#
# 1）如果有多个从属能够进行故障转移，
#    则它们交换消息，以尝试利用具有最佳复制偏移量的从属服务器（处理来自主服务器的更多数据）来获得优势。
#    从站将尝试按偏移量获得其等级，并将一个与它们的等级成比例的延迟应用于故障转移。
#
# 2）每个从属设备都计算与主控设备之间最后一次交互的时间。
#    这可以是最后收到的ping或命令（如果主服务器仍处于“已连接”状态），
#    或自与主服务器断开连接以来经过的时间（如果复制链接当前已关闭）。
#    如果最后一次交互太旧，则从服务器将完全不会尝试故障转移。
#
# The point "2" can be tuned by user. Specifically a slave will not perform the failover if,
# since the last interaction with the master, the time elapsed is greater than:
# 用户可以调整点“ 2”。具体来说，
# 如果从上次与主服务器进行交互以来经过的时间大于以下时间，则从服务器将不执行故障转移：
#
#   (node-timeout * slave-validity-factor) + repl-ping-slave-period
#
# So for example if node-timeout is 30 seconds, and the slave-validity-factor is 10,
# and assuming a default repl-ping-slave-period of 10 seconds,
# the slave will not try to failover if it was not able to talk with the master for longer than 310 seconds.
# 因此，例如，如果node-timeout为30秒，并且slave-validity-factor为10，
# 并假设默认的repl-ping-slave-period值为10秒，
# 如果从属无法执行，则从属将不会尝试故障转移与主对话时间超过310秒。
#
# A large slave-validity-factor may allow slaves with too old data to failover a master,
# while a too small value may prevent the cluster from being able to elect a slave at all.
# 较大的从设备有效性因素可能会使数据太旧的从设备无法进行主设备故障转移，
# 然而值太小可能会使群集完全无法选择从设备。
#
# For maximum availability, it is possible to set the slave-validity-factor to a value of 0, which means,
# that slaves will always try to failover the master regardless of the last time they interacted with the master.
# (However they'll always try to apply a delay proportional to their offset rank).
# 为了获得最大的可用性，可以将slave-validity-factor设置为0，这意味着，
# 从站将始终尝试对主站进行故障转移，而不管它们上次与主站进行交互的时间如何。
#（但是，他们将始终尝试应用与其偏移等级成比例的延迟）。
#
# Zero is the only value able to guarantee that when all the partitions heal the cluster will always be able to continue.
# 零是唯一能够保证当所有分区恢复正常后群集将始终能够继续运行的值。
#
# cluster-slave-validity-factor 10

# Cluster slaves are able to migrate to orphaned masters,
# that are masters that are left without working slaves.
# This improves the cluster ability to resist to failures as otherwise an orphaned master can't be failed over in case of failure if it has no working slaves.
# 群集从属服务器能够迁移到孤立的主服务器，即孤立的主服务器，这些主服务器没有工作的从属服务器。
# 这可以提高群集抵抗故障的能力，否则如果孤立的主节点没有可用的从属节点，则在发生故障时无法进行故障转移。
#
# Slaves migrate to orphaned masters only if there are still at least a given number of other working slaves for their old master.
# This number is the "migration barrier".
# A migration barrier of 1 means that a slave will migrate only if there is at least 1 other working slave for its master and so forth.
# It usually reflects the number of slaves you want for every master in your cluster.
# 仅当旧主机中至少还有给定数量的其他工作从机时，从机才会迁移到孤立的主机。
# 这个数字是“移民壁垒”。
# 迁移屏障为1表示从属服务器仅在至少有1个其他正在工作的从属服务器为其主机等时才进行迁移。
# 它通常反映集群中每个主节点所需的从节点数量。
#
# Default is 1 (slaves migrate only if their masters remain with at least one slave).
# To disable migration just set it to a very large value.
# A value of 0 can be set but is useful only for debugging and dangerous in production.
# 默认值为1（从站仅在其主站至少保留一个从站的情况下迁移）。
# 要禁用迁移，只需将其设置为非常大的值即可。
# 可以设置为0，但仅对调试和生产危险有用。
#
# cluster-migration-barrier 1

# By default Redis Cluster nodes stop accepting queries if they detect there is at least an hash slot uncovered (no available node is serving it).
# This way if the cluster is partially down (for example a range of hash slots are no longer covered) all the cluster becomes, eventually, unavailable.
# It automatically returns available as soon as all the slots are covered again.
# 默认情况下，如果Redis Cluster节点检测到至少发现一个哈希槽（没有可用的节点正在为其提供服务），它们将停止接受查询。
# 这样，如果群集部分关闭（例如，不再覆盖一定范围的哈希槽），则所有群集最终将变得不可用。
# 重新覆盖所有插槽后，它将自动返回可用状态。
#
# However sometimes you want the subset of the cluster which is working,
# to continue to accept queries for the part of the key space that is still covered.
# In order to do so, just set the cluster-require-full-coverage option to no.
# 但是有时您希望集群的子集正常工作，
# 继续接受对仍覆盖的键空间部分的查询。
# 为此，只需将cluster-require-full-coverage选项设置为no。
#
# cluster-require-full-coverage yes

# In order to setup your cluster make sure to read the documentation
# 为了设置您的集群，请务必阅读文档
# available at http://redis.io web site.

################################## SLOW LOG ###################################

# The Redis Slow Log is a system to log queries that exceeded a specified execution time.
# The execution time does not include the I/O operations like talking with the client, sending the reply and so forth,
# but just the time needed to actually execute the command
# (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).
# Redis Slow Log是一个用于记录超过指定执行时间的查询的系统。
# 执行时间不包括I / O操作（例如与客户交谈，发送回复等），
# 但仅是实际执行命令所需的时间（这是命令执行的唯一阶段，在该阶段线程被阻塞并且不能同时满足其他请求）。
#
# You can configure the slow log with two parameters:
# one tells Redis what is the execution time, in microseconds,
# to exceed in order for the command to get logged, and the other parameter is the length of the slow log.
# When a new command is logged the oldest one is removed from the queue of logged commands.
# 您可以使用两个参数配置慢速日志：
# 一个告诉Redis执行时间（以微秒为单位），超过该时间才能使命令被记录下来，
# 而另一个参数是慢速日志的长度。
# 记录新命令时，最旧的命令将从记录的命令队列中删除。

# The following time is expressed in microseconds, so 1000000 is equivalent to one second.
# Note that a negative number disables the slow log, while a value of zero forces the logging of every command.
# 以下时间以微秒表示，因此1000000等于一秒。
# 注意，负数将禁用慢速日志记录，而零值将强制记录每个命令。
slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory.
# You can reclaim memory used by the slow log with SLOWLOG RESET.
# 该长度没有限制。请注意，它将消耗内存。
# 您可以使用SLOWLOG RESET回收慢速日志使用的内存。
slowlog-max-len 128

################################ LATENCY MONITOR ##############################

# The Redis latency monitoring subsystem samples different operations at runtime in order to collect data related to possible sources of latency of a Redis instance.
# Redis延迟监视子系统会在运行时对不同的操作进行采样，以收集与Redis实例的潜在延迟源相关的数据。
#
# Via the LATENCY command this information is available to the user that can print graphs and obtain reports.
# 通过LATENCY命令，该信息可供可以打印图形并获取报告的用户使用。
#
# The system only logs operations that were performed in a time equal or greater than the amount of milliseconds specified via the latency-monitor-threshold configuration directive.
# When its value is set to zero, the latency monitor is turned off.
# 系统仅记录在等于或大于通过delay-monitor-threshold配置指令指定的毫秒量的时间内执行的操作。
# 当其值设置为零时，等待时间监视器将关闭。
#
# By default latency monitoring is disabled since it is mostly not needed if you don't have latency issues,
# and collecting data has a performance impact, that while very small, can be measured under big load.
# Latency monitoring can easily be enabled at runtime using the command "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
# 默认情况下，延迟监视是禁用的，因为如果您没有延迟问题，则通常不需要它。
# 和收集数据会对性能产生影响，尽管影响很小，但是可以在大负载下进行测量。
# 如果需要，可以在运行时使用命令“ CONFIG SET delay-monitor-threshold <milliseconds>”轻松启用延迟监视。
latency-monitor-threshold 0

############################# EVENT NOTIFICATION ##############################

# Redis can notify Pub/Sub clients about events happening in the key space.
# Redis可以通知发布/订阅客户端有关密钥空间中发生的事件。
# This feature is documented at http://redis.io/topics/notifications
#
# For instance if keyspace events notification is enabled,
# and a client performs a DEL operation on key "foo" stored in the Database 0,
# two messages will be published via Pub/Sub:
# 例如，如果启用了键空间事件通知，
# 并且客户端对存储在数据库0中的键“ foo”执行DEL操作，则将通过Pub / Sub发布两个消息：
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set of classes.
# Every class is identified by a single character:
# 可以在一组类中选择Redis将通知的事件。
# 每个类别都由一个字符标识：
#
#  K     Keyspace events, published with __keyspace@<db>__ prefix.
#  E     Keyevent events, published with __keyevent@<db>__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events (events generated every time a key expires)
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
#
#  The "notify-keyspace-events" takes as argument a string that is composed of zero or multiple characters.
#  The empty string means that notifications are disabled.
#  “ notify-keyspace-events”将由零个或多个字符组成的字符串作为参数。
#  空字符串表示已禁用通知。
#
#  Example: to enable list and generic events, from the point of view of the event name, use:
#  示例：要启用列表事件和通用事件，请从事件名称的角度使用：
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys subscribing to channel name __keyevent@0__:expired use:
#  示例2：获取订阅频道名称__keyevent @ 0 __：expired的过期密钥流：
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because most users don't need this feature and the feature has some overhead.
#  Note that if you don't specify at least one of K or E, no events will be delivered.
#  默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，并且该功能有一些开销。
#  请注意，如果您未指定K或E中的至少一个，则不会传递任何事件。
notify-keyspace-events ""

############################### ADVANCED CONFIG ###############################

# Hashes are encoded using a memory efficient data structure when they have a small number of entries, and the biggest entry does not exceed a given threshold.
# These thresholds can be configured using the following directives.
# 当哈希条目数较少且最大条目数不超过给定阈值时，将使用内存高效的数据结构对其进行编码。
# 可以使用以下指令配置这些阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Lists are also encoded in a special way to save a lot of space.
# The number of entries allowed per internal list node can be specified as a fixed maximum size or a maximum number of elements.
# For a fixed maximum size, use -5 through -1, meaning:
# 列表也以特殊方式编码，以节省大量空间。
# 每个内部列表节点允许的条目数可以指定为固定的最大大小或最大元素数。
# 对于固定的最大大小，请使用-5到-1，表示：
# -5: max size: 64 Kb  <-- not recommended for normal workloads
# -4: max size: 32 Kb  <-- not recommended
# -3: max size: 16 Kb  <-- probably not recommended
# -2: max size: 8 Kb   <-- good
# -1: max size: 4 Kb   <-- good
# Positive numbers mean store up to _exactly_ that number of elements per list node.
# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
# but if your use case is unique, adjust the settings as necessary.
# 正数表示每个列表节点最多可以存储该数量的元素。
# 效果最好的选项通常是-2（8 Kb大小）或-1（4 Kb大小），
# 但如果您的用例是唯一的，请根据需要调整设置。
list-max-ziplist-size -2

# Lists may also be compressed.
# Compress depth is the number of quicklist ziplist nodes from *each* side of the list to *exclude* from compression.
# The head and tail of the list are always uncompressed for fast push/pop operations.
# 列表也可以被压缩。
# 压缩深度是指从列表的*每个*侧到*排除*压缩的快速列表ziplist节点的数量。
# 为了快速执行推/弹出操作，列表的首尾始终未压缩。
# Settings are:
# 0: disable all list compression
# 1: depth 1 means "don't start compressing until after 1 node into the list, going from either the head or tail"
#    So: [head]->node->node->...->node->[tail]
#    [head], [tail] will always be uncompressed; inner nodes will compress.
# 2: [head]->[next]->node->node->...->node->[prev]->[tail]
#    2 here means: don't compress head or head->next or tail->prev or tail,
#    but compress all nodes between them.
# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
# etc.
list-compress-depth 0

# Sets have a special encoding in just one case:
# when a set is composed of just strings that happen to be integers in radix 10 in the range of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the set in order to use this special memory saving encoding.
# 在仅一种情况下，集合具有特殊的编码：
# 当集合仅由恰好是基数10中的整数（在64位有符号整数范围内）的字符串组成时。
# 以下配置设置设置了大小限制，以便使用此特殊的内存节省编码。
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in order to save a lot of space.
# This encoding is only used when the length and elements of a sorted set are below the following limits:
# 与散列和列表类似，对排序集也进行了特殊编码，以节省大量空间。
# 仅当排序集的长度和元素低于以下限制时，才使用此编码：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog sparse representation bytes limit.
# The limit includes the 16 bytes header.
# When an HyperLogLog using the sparse representation crosses this limit, it is converted into the dense representation.
# HyperLogLog稀疏表示形式的字节数限制。
# 限制包括16个字节的标头。
# 当使用稀疏表示的HyperLogLog超过此限制时，它将转换为密集表示。
#
# A value greater than 16000 is totally useless, since at that point the dense representation is more memory efficient.
# 大于16000的值是完全没有用的，因为在那一点上，密集表示的存储效率更高。
#
# The suggested value is ~ 3000 in order to have the benefits of the space efficient encoding without slowing down too much PFADD,
# which is O(N) with the sparse encoding. The value can be raised to ~ 10000 when CPU is not a concern,
# but space is, and the data set is composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
# 建议值约为3000，以便在不减慢PFADD的情况下获得节省空间编码的优势，是稀疏编码的O（N）。
# 如果不考虑CPU，而是空格，并且数据集由基数在0-15000范围内的许多HyperLogLog组成，则该值可以提高到10000。
hll-sparse-max-bytes 3000

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in order to help rehashing the main Redis hash table
# (the one mapping top-level keys to values).
# The hash table implementation Redis uses (see dict.c) performs a lazy rehashing:
# the more operation you run into a hash table that is rehashing,
# the more rehashing "steps" are performed, so if the server is idle the rehashing is never complete and some more memory is used by the hash table.
# 活动重新哈希处理每100毫秒CPU时间使用1毫秒，以帮助重新哈希主Redis哈希表＃（将顶级键映射到值的一个哈希表）。
# Redis使用的哈希表实现（请参阅dict.c）执行一次懒惰的重新哈希处理：
# 您在要重新哈希处理的哈希表中运行的操作越多，
# 执行的哈希处理步骤越多，因此，如果服务器处于空闲状态，
# 则需要重新哈希处理永远不会完成，哈希表会使用更多的内存。
#
# The default is to use this millisecond 10 times every second in order to actively rehash the main dictionaries, freeing memory when possible.
# 默认值是每秒使用10毫秒的毫秒数来主动重新哈希主字典，并在可能的情况下释放内存。
#
# If unsure:
# use "activerehashing no" if you have hard latency requirements and it is not a good thing in your environment that Redis can reply from time to time to queries with 2 milliseconds delay.
# 如果不确定：
# 如果您有严格的延迟要求，请使用“ activerehashing no”，并且在您的环境中，Redis可以不时地以2毫秒的延迟答复查询不是一件好事。
#
# use "activerehashing yes" if you don't have such hard requirements but want to free memory asap when possible.
# 如果您没有如此严格的要求，但希望在可能的情况下尽快释放内存，请使用“ activerehashing yes”。
activerehashing yes

# The client output buffer limits can be used to force disconnection of clients that are not reading data from the server fast enough for some reason
# (a common reason is that a Pub/Sub client can't consume messages as fast as the publisher can produce them).
# 客户端输出缓冲区限制可用于强制出于某些原因＃未能以足够快的速度从服务器读取数据的客户端断开连接
#（常见原因是Pub / Sub客户端无法像发布者所产生的那样快地消费消息）。
#
# The limit can be set differently for the three different classes of clients:
# 可以为三种不同类别的客户设置不同的限制:
#
# normal -> normal clients including MONITOR clients
# normal -> 普通客户，包括MONITOR客户
# slave  -> slave clients
# slave  -> 奴隶客户
# pubsub -> clients subscribed to at least one pubsub channel or pattern
# pubsub -> 客户订阅了至少一个pubsub频道或模式
#
# The syntax of every client-output-buffer-limit directive is the following:
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
# 每个client-output-buffer-limit指令的语法如下：
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# A client is immediately disconnected once the hard limit is reached,
# or if the soft limit is reached and remains reached for the specified number of seconds (continuously).
# So for instance if the hard limit is 32 megabytes and the soft limit is 16 megabytes / 10 seconds,
# the client will get disconnected immediately if the size of the output buffers reach 32 megabytes,
# but will also get disconnected if the client reaches 16 megabytes and continuously overcomes the limit for 10 seconds.
# 一旦达到硬限制，客户端将立即断开连接，
# 或是否达到软限制，并在指定的秒数内（连续）保持达到软限制。
# 例如，如果硬限制为32 MB，软限制为16 MB / 10秒，
# 如果输出缓冲区的大小达到32兆字节，客户端将立即断开连接，
# 如果客户端达到16兆字节并连续超过10秒钟，则客户端也会断开连接。
#
# By default normal clients are not limited because they don't receive data without asking (in a push way),
# but just after a request, so only asynchronous clients may create a scenario where data is requested faster than it can read.
# 默认情况下，普通客户不受限制，因为他们不会不询问就以推送方式接收数据，
# 但仅在请求之后，因此只有异步客户端才能创建这样一种情况：请求数据的速度比读取数据的速度快。
#
# Instead there is a default limit for pubsub and slave clients, since subscribers and slaves receive data in a push fashion.
# 相反，由于订阅者和从属者以推送方式接收数据，因此对pubsub和slave客户端没有默认限制。
#
# Both the hard or the soft limit can be disabled by setting them to zero.
# 硬限制或软限制都可以通过将其设置为零来禁用。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Redis calls an internal function to perform many background tasks,
# like closing connections of clients in timeot,
# purging expired keys that are never requested, and so forth.
# Redis调用一个内部函数来执行许多后台任务，
# 例如在timeot中关闭客户端连接，
# 清除从未请求的过期密钥，等等。
#
# Not all tasks are perforemd with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
# 并非所有任务的执行频率都相同，但是Redis会检查根据指定的“ hz”值执行的任务。
#
# By default "hz" is set to 10. Raising the value will use more CPU when Redis is idle,
# but at the same time will make Redis more responsive when there are many keys expiring at the same time,
# and timeouts may be handled with more precision.
# 默认情况下，“ hz”设置为10。提高该值将在Redis空闲时使用更多的CPU，
# 但同时有很多键同时到期时，它将使Redis的响应速度更快，＃和超时可能得到处理更精确。
#
# The range is between 1 and 500, however a value over 100 is usually not a good idea.
# Most users should use the default of 10 and raise this up to 100 only in environments where very low latency is required.
# 范围在1到500之间，但是通常不建议超过100。
# 大多数用户应使用默认值10，仅在要求非常低延迟的环境中才将其提高到100。
hz 10

# When a child rewrites the AOF file, if the following option is enabled the file will be fsync-ed every 32 MB of data generated.
# This is useful in order to commit the file to the disk more incrementally and avoid big latency spikes.
# 当孩子重写AOF文件时，如果启用了以下选项，则每生成32 MB的数据，文件就会进行同步处理。
# 这对于将文件更多地提交到磁盘并避免大的延迟峰值很有用。
aof-rewrite-incremental-fsync yes

################################## INCLUDES ###################################

# Include one or more other config files here.
# This is useful if you have a standard template that goes to all Redis server but also need to customize a few per-server settings.
# Include files can include other files, so use this wisely.
# 在此处包括一个或多个其他配置文件。
# 如果您有一个标准模板可用于所有Redis服务器，但还需要自定义一些服务器设置，则此功能很有用。
# 包含文件可以包含其他文件，因此请明智地使用此文件
#
# include /path/to/local.conf
# include /path/to/other.conf
